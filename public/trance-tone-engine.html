<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trance Tone Engine</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=JetBrains+Mono:wght@200;300&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #08060d;
    --text-dim: rgba(180, 170, 200, 0.5);
    --text-bright: rgba(220, 210, 240, 0.9);
  }

  body {
    background: var(--bg);
    color: var(--text-bright);
    font-family: 'Cormorant Garamond', serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    cursor: none;
  }

  #app { width: 100%; height: 100%; position: relative; }

  canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }

  .overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }

  .word-display {
    font-size: clamp(2rem, 6vw, 5rem);
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: lowercase;
    transition: opacity 1.2s ease, transform 1.2s ease, filter 1.2s ease;
    text-align: center;
    line-height: 1.2;
    filter: blur(0px);
    max-width: 80vw;
  }

  .word-display.fading {
    opacity: 0;
    transform: scale(0.92) translateY(10px);
    filter: blur(6px);
  }

  .formula-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: clamp(0.6rem, 1.2vw, 0.85rem);
    font-weight: 200;
    color: var(--text-dim);
    margin-top: 2rem;
    letter-spacing: 0.08em;
    transition: opacity 1.5s ease;
    text-align: center;
  }

  .category-label {
    font-size: clamp(0.55rem, 1vw, 0.7rem);
    font-weight: 300;
    font-style: italic;
    color: rgba(180, 170, 200, 0.3);
    margin-bottom: 0.8rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    transition: opacity 1.5s ease, color 1s ease;
  }

  .beat-info {
    font-family: 'JetBrains Mono', monospace;
    font-size: clamp(0.5rem, 0.9vw, 0.65rem);
    font-weight: 200;
    color: rgba(180, 170, 200, 0.25);
    margin-top: 0.6rem;
    letter-spacing: 0.1em;
    transition: opacity 1.5s ease;
  }

  .click-hint {
    position: absolute;
    bottom: 3vh;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    font-weight: 200;
    color: rgba(180, 170, 200, 0.2);
    letter-spacing: 0.3em;
    text-transform: uppercase;
    z-index: 3;
    pointer-events: none;
    animation: pulse-hint 3s ease-in-out infinite;
  }

  @keyframes pulse-hint {
    0%, 100% { opacity: 0.15; }
    50% { opacity: 0.4; }
  }

  .audio-init-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 50;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(8, 6, 13, 0.95);
    cursor: pointer;
    transition: opacity 0.8s ease;
  }

  .audio-init-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .audio-init-overlay h1 {
    font-size: clamp(1.8rem, 4vw, 3.5rem);
    font-weight: 300;
    letter-spacing: 0.2em;
    margin-bottom: 1rem;
    color: rgba(220, 210, 240, 0.8);
  }

  .audio-init-overlay p {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 200;
    color: rgba(180, 170, 200, 0.4);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-top: 0.5rem;
  }

  .audio-init-overlay .headphones-warn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    font-weight: 200;
    color: rgba(200, 140, 140, 0.5);
    letter-spacing: 0.12em;
    margin-top: 2rem;
  }

  .cursor-glow {
    position: fixed;
    width: 20px; height: 20px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 100;
    transform: translate(-50%, -50%);
    transition: width 0.3s, height 0.3s, background 0.8s;
    mix-blend-mode: screen;
  }

  .timelapse-bar {
    position: absolute;
    bottom: 0; left: 0;
    height: 2px;
    z-index: 3;
    transition: background 0.8s ease;
    opacity: 0.6;
  }

  .volume-control {
    position: absolute;
    top: 2vh; right: 2vw;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 8px;
    pointer-events: all;
  }

  .volume-control label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.55rem;
    font-weight: 200;
    color: rgba(180, 170, 200, 0.3);
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .volume-control input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 80px;
    height: 2px;
    background: rgba(180, 170, 200, 0.15);
    outline: none;
    border-radius: 1px;
    cursor: pointer;
  }

  .volume-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(180, 170, 200, 0.5);
    cursor: pointer;
  }

  .volume-control input[type="range"]::-moz-range-thumb {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(180, 170, 200, 0.5);
    cursor: pointer;
    border: none;
  }
</style>
</head>
<body>
<div id="app">
  <trance-engine></trance-engine>
</div>

<script>
const { createApp, ref, onMounted, onUnmounted, computed, nextTick } = Vue;

// ══════════════════════════════════════════════════════════════
// BINAURAL BEAT AUDIO ENGINE
// Gamma range binaural beats via Web Audio API
// Technique: L channel = carrier - beat/2, R channel = carrier + beat/2
// The brain perceives the difference as a "beat" at the gamma frequency
// ══════════════════════════════════════════════════════════════
class BinauralEngine {
  constructor() {
    this.ctx = null;
    this.oscLeft = null;
    this.oscRight = null;
    this.masterGain = null;
    this.merger = null;
    this.analyser = null;
    this.carrier = 220;
    this.beatFreq = 40;
    this.started = false;
    this.dataArray = null;
  }

  init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();

    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.12;

    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 256;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

    this.merger = this.ctx.createChannelMerger(2);

    // Left ear oscillator
    this.oscLeft = this.ctx.createOscillator();
    const gainL = this.ctx.createGain();
    this.oscLeft.type = 'sine';
    this.oscLeft.frequency.value = this.carrier - this.beatFreq / 2;
    gainL.gain.value = 1;
    this.oscLeft.connect(gainL);
    gainL.connect(this.merger, 0, 0);

    // Right ear oscillator
    this.oscRight = this.ctx.createOscillator();
    const gainR = this.ctx.createGain();
    this.oscRight.type = 'sine';
    this.oscRight.frequency.value = this.carrier + this.beatFreq / 2;
    gainR.gain.value = 1;
    this.oscRight.connect(gainR);
    gainR.connect(this.merger, 0, 1);

    this.merger.connect(this.masterGain);
    this.masterGain.connect(this.analyser);
    this.analyser.connect(this.ctx.destination);

    this.oscLeft.start();
    this.oscRight.start();
    this.started = true;
  }

  setBeat(beatHz, carrierHz, rampTime = 1.5) {
    if (!this.started) return;
    const now = this.ctx.currentTime;
    this.carrier = carrierHz || this.carrier;
    this.beatFreq = beatHz;

    this.oscLeft.frequency.cancelScheduledValues(now);
    this.oscRight.frequency.cancelScheduledValues(now);
    this.oscLeft.frequency.setValueAtTime(this.oscLeft.frequency.value, now);
    this.oscRight.frequency.setValueAtTime(this.oscRight.frequency.value, now);
    this.oscLeft.frequency.linearRampToValueAtTime(this.carrier - beatHz / 2, now + rampTime);
    this.oscRight.frequency.linearRampToValueAtTime(this.carrier + beatHz / 2, now + rampTime);
  }

  setVolume(val) {
    if (!this.started) return;
    const now = this.ctx.currentTime;
    this.masterGain.gain.cancelScheduledValues(now);
    this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, now);
    this.masterGain.gain.linearRampToValueAtTime(val, now + 0.3);
  }

  getWaveformData() {
    if (!this.analyser) return null;
    const d = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteTimeDomainData(d);
    return d;
  }

  destroy() {
    try { this.oscLeft && this.oscLeft.stop(); } catch(e) {}
    try { this.oscRight && this.oscRight.stop(); } catch(e) {}
    try { this.ctx && this.ctx.close(); } catch(e) {}
    this.started = false;
  }
}


const TranceEngine = {
  setup() {
    const canvasRef = ref(null);
    const mouseX = ref(window.innerWidth / 2);
    const mouseY = ref(window.innerHeight / 2);
    const currentWord = ref('');
    const currentFormula = ref('');
    const currentCategory = ref('');
    const currentBeatInfo = ref('');
    const isFading = ref(false);
    const timelapseProgress = ref(0);
    const accentColor = ref('rgba(123, 94, 167, 0.4)');
    const audioInitialized = ref(false);
    const volume = ref(12);
    let animFrame = null;
    let timelapseTimer = null;
    const binaural = new BinauralEngine();

    /*
     * GAMMA BINAURAL BEAT MAPPING PER CATEGORY
     * ─────────────────────────────────────────
     * Focus:      40 Hz beat @ 220 Hz carrier — classic gamma, peak concentration
     * Relaxation: 32 Hz beat @ 180 Hz carrier — low gamma boundary, calm alertness
     * Deepening:  36 Hz beat @ 160 Hz carrier — mid gamma, trance induction
     * Sensory:    44 Hz beat @ 250 Hz carrier — high gamma, vivid imagery/creativity
     * Suggestion: 38 Hz beat @ 200 Hz carrier — steady gamma, suggestibility/receptivity
     */

    function getAudioEnergy(waveform) {
      if (!waveform) return 0;
      let sum = 0;
      for (let i = 0; i < waveform.length; i++) sum += Math.abs(waveform[i] - 128);
      return sum / waveform.length / 128;
    }

    const categories = {
      focus: {
        label: 'Focus & Visual Engagement',
        formula: 'r(θ) = a·e^(bθ) · cos(ωt)',
        words: ['spiral', 'spinning', 'focus', 'stare deeper', 'center', 'fixate', 'gaze', 'swirling'],
        color: 'rgba(123, 94, 167, 0.5)',
        colorBright: '#7b5ea7',
        beatHz: 40, carrier: 220,
        draw(ctx, w, h, t, mx, my, wf) {
          const cx = w/2, cy = h/2, ae = getAudioEnergy(wf);
          for (let layer = 0; layer < 3; layer++) {
            ctx.beginPath();
            const off = layer * 0.7 + t * 0.3;
            for (let i = 0; i <= 800; i++) {
              const theta = (i/800) * 12 * Math.PI + off;
              const r = 2 * Math.exp(0.12 * theta) * (1 + (0.15 + ae*0.2) * Math.sin(t*2 + theta*0.5));
              const x = cx + r * Math.cos(theta), y = cy + r * Math.sin(theta);
              i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.strokeStyle = `rgba(123,94,167,${0.15 - layer*0.04 + ae*0.08})`;
            ctx.lineWidth = 1.5 - layer*0.3;
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(cx, cy, 4 + 2*Math.sin(t*3) + ae*8, 0, Math.PI*2);
          ctx.fillStyle = `rgba(200,180,240,${0.6+0.3*Math.sin(t*3)})`;
          ctx.fill();
          const inf = Math.max(0, 1 - Math.hypot(mx-cx,my-cy)/(w*0.4));
          for (let r = 0; r < 5; r++) {
            ctx.beginPath();
            ctx.arc(cx, cy, 30+r*40-inf*15+5*Math.sin(t*2+r)+ae*10, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(123,94,167,${0.08+inf*0.1})`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
          }
        }
      },
      relaxation: {
        label: 'Relaxation & Physical Surrender',
        formula: 'y(t) = A·e^(-λt) · sin(ωt + φ)',
        words: ['relax', 'soothe', 'heavy', 'close', 'drift', 'float', 'let go', 'release'],
        color: 'rgba(58, 107, 138, 0.5)',
        colorBright: '#3a6b8a',
        beatHz: 32, carrier: 180,
        draw(ctx, w, h, t, mx, my, wf) {
          const cy = h/2, ae = getAudioEnergy(wf);
          for (let wave = 0; wave < 6; wave++) {
            ctx.beginPath();
            const phi = wave*0.8 + t*0.2;
            for (let x = 0; x <= w; x += 2) {
              const nX = x/w*8;
              const env = h*0.3*Math.exp(-0.4*Math.abs(nX-4));
              const y = cy + env*Math.sin(2.5*nX+phi+t*0.5)*(1+ae*0.3)+wave*8;
              x === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.strokeStyle = `rgba(58,107,138,${0.12-wave*0.015+ae*0.05})`;
            ctx.lineWidth = 2-wave*0.2;
            ctx.stroke();
          }
          for (let p = 0; p < 20; p++) {
            const s = p*137.508;
            const px = w*0.2 + w*0.6*((Math.sin(s)+1)/2);
            const py = cy + h*0.3*Math.sin(s*0.7+t*0.3)*Math.exp(-0.1*(t%10));
            ctx.beginPath();
            ctx.arc(px, py, 1.5+Math.sin(t+s)*0.8+ae*3, 0, Math.PI*2);
            ctx.fillStyle = `rgba(100,170,210,${0.15+0.1*Math.sin(t+s)})`;
            ctx.fill();
          }
        }
      },
      deepening: {
        label: 'Deepening Trance',
        formula: 'd(t) = D / (1 + e^(k·(t - t₀)))',
        words: ['deeper', 'deeper and deeper', 'descend', 'sink', 'trance', 'hypnotic trance', 'deep trance', 'unconscious'],
        color: 'rgba(26, 26, 62, 0.8)',
        colorBright: '#2a2a5e',
        beatHz: 36, carrier: 160,
        draw(ctx, w, h, t, mx, my, wf) {
          const cx = w/2, cy = h/2, ae = getAudioEnergy(wf);
          for (let i = 12; i >= 0; i--) {
            const sig = 1/(1+Math.exp(5*((t*0.4)%(12*0.8+4)-i*0.8)));
            const r = sig*Math.min(w,h)*0.45+5+ae*20;
            ctx.beginPath();
            ctx.arc(cx, cy, Math.max(r,2), 0, Math.PI*2);
            const d = 1-i/12;
            ctx.fillStyle = `rgba(${20+d*20},${15+d*15},${50+d*40},${0.08+d*0.04})`;
            ctx.fill();
            ctx.strokeStyle = `rgba(80,70,130,${0.06+sig*0.08+ae*0.06})`;
            ctx.lineWidth = 0.6;
            ctx.stroke();
          }
          for (let l = 0; l < 8; l++) {
            const a = l/8*Math.PI*2+t*0.1;
            const len = 50+150*((Math.sin(t*0.5+l)+1)/2)+ae*60;
            ctx.beginPath();
            ctx.moveTo(cx+20*Math.cos(a), cy+20*Math.sin(a));
            ctx.lineTo(cx+len*Math.cos(a), cy+len*Math.sin(a));
            ctx.strokeStyle = `rgba(60,50,120,${0.12+ae*0.1})`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        }
      },
      sensory: {
        label: 'Sensory & Imaginative Guidance',
        formula: 'f(x,t) = Σ sin(n·x + t) / n',
        words: ['imagine', 'pretend', 'visualize', 'breathe deeply', 'gentle breeze', 'flowing', 'washes away', 'refreshing'],
        color: 'rgba(90, 138, 107, 0.5)',
        colorBright: '#5a8a6b',
        beatHz: 44, carrier: 250,
        draw(ctx, w, h, t, mx, my, wf) {
          const gs = 28, ae = getAudioEnergy(wf);
          for (let gy = 0; gy < Math.ceil(h/gs)+1; gy++) {
            for (let gx = 0; gx < Math.ceil(w/gs)+1; gx++) {
              let val = 0;
              for (let n = 1; n <= 4; n++) {
                val += Math.sin(n*gx*0.3+t*0.5+n)/n + Math.cos(n*gy*0.25+t*0.4+n*2)/n;
              }
              const norm = (val+3)/6;
              const len = norm*gs*(0.8+ae*0.5);
              const angle = val*Math.PI+t*0.2;
              const x = gx*gs, y = gy*gs;
              ctx.beginPath();
              ctx.moveTo(x,y);
              ctx.lineTo(x+len*Math.cos(angle), y+len*Math.sin(angle));
              ctx.strokeStyle = `rgba(90,${100+norm*80},107,${0.06+norm*0.08})`;
              ctx.lineWidth = 0.6+norm*0.8;
              ctx.stroke();
            }
          }
          const bc = Math.sin(t*0.8)*0.5+0.5;
          ctx.beginPath();
          ctx.arc(w/2, h/2, 40+bc*80+ae*30, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(120,200,150,${0.08+bc*0.1+ae*0.08})`;
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      },
      suggestion: {
        label: 'Suggestion & Reinforcement',
        formula: 's(t) = Σ Aₙ · cos(n·ω·t)',
        words: ['allow', 'effortless', 'calm', 'tranquil', 'peaceful', 'serene', 'because'],
        color: 'rgba(138, 122, 90, 0.5)',
        colorBright: '#8a7a5a',
        beatHz: 38, carrier: 200,
        draw(ctx, w, h, t, mx, my, wf) {
          const cx = w/2, cy = h/2, ae = getAudioEnergy(wf);
          for (let n = 1; n <= 5; n++) {
            const An = 1/n;
            ctx.beginPath();
            for (let x = 0; x <= w; x += 2) {
              const nX = (x/w)*Math.PI*4;
              const y = cy + h*(0.15+ae*0.05)*An*Math.cos(n*1.2*t)*Math.sin(n*nX);
              x === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.strokeStyle = `rgba(180,160,110,${0.08+An*0.06+ae*0.04})`;
            ctx.lineWidth = 1.2;
            ctx.stroke();
          }
          for (let nd = 0; nd < 8; nd++) {
            const nx = (nd+1)/9*w;
            let itf = 0;
            for (let n = 1; n <= 5; n++) itf += (1/n)*Math.cos(n*1.2*t)*Math.sin(n*(nx/w)*Math.PI*4);
            ctx.beginPath();
            ctx.arc(nx, cy+itf*h*0.15, 2+Math.abs(itf)*4+ae*5, 0, Math.PI*2);
            ctx.fillStyle = `rgba(220,200,140,${0.1+Math.abs(itf)*0.25})`;
            ctx.fill();
          }
          const grad = ctx.createRadialGradient(cx,cy,10,cx,cy,Math.min(w,h)*0.4);
          grad.addColorStop(0, `rgba(138,122,90,${0.04+0.02*Math.sin(t)})`);
          grad.addColorStop(1, 'rgba(138,122,90,0)');
          ctx.fillStyle = grad;
          ctx.fillRect(0,0,w,h);
        }
      }
    };

    const categoryKeys = Object.keys(categories);
    let currentCatKey = ref('focus');
    let globalTime = 0;
    const TIMELAPSE_DURATION = 4500;

    function pickRandom() {
      const k = categoryKeys[Math.floor(Math.random()*categoryKeys.length)];
      return { catKey: k, word: categories[k].words[Math.floor(Math.random()*categories[k].words.length)] };
    }

    function transitionTo(catKey, word) {
      isFading.value = true;
      setTimeout(() => {
        currentCatKey.value = catKey;
        const cat = categories[catKey];
        currentWord.value = word;
        currentFormula.value = cat.formula;
        currentCategory.value = cat.label;
        accentColor.value = cat.color;
        if (binaural.started) binaural.setBeat(cat.beatHz, cat.carrier, 1.5);
        const L = (cat.carrier - cat.beatHz/2).toFixed(0);
        const R = (cat.carrier + cat.beatHz/2).toFixed(0);
        currentBeatInfo.value = `\u03B3 ${cat.beatHz} Hz binaural \u00B7 ${cat.carrier} Hz carrier \u00B7 L ${L} Hz \u00B7 R ${R} Hz`;
        nextTick(() => { isFading.value = false; });
      }, 600);
    }

    function triggerNext() {
      const { catKey, word } = pickRandom();
      transitionTo(catKey, word);
      timelapseProgress.value = 0;
      clearInterval(timelapseTimer);
      const start = Date.now();
      timelapseTimer = setInterval(() => {
        const el = Date.now() - start;
        timelapseProgress.value = Math.min(el / TIMELAPSE_DURATION, 1);
        if (el >= TIMELAPSE_DURATION) { clearInterval(timelapseTimer); triggerNext(); }
      }, 30);
    }

    function initAudio() {
      if (audioInitialized.value) return;
      binaural.init();
      audioInitialized.value = true;
      triggerNext();
    }

    function handleClick(e) {
      if (e.target.closest && e.target.closest('.volume-control')) return;
      if (!audioInitialized.value) { initAudio(); return; }
      triggerNext();
    }

    function handleMouseMove(e) { mouseX.value = e.clientX; mouseY.value = e.clientY; }

    function handleVolumeChange(e) {
      volume.value = parseInt(e.target.value);
      binaural.setVolume(volume.value / 100 * 0.25);
    }

    function animate() {
      const canvas = canvasRef.value;
      if (!canvas) { animFrame = requestAnimationFrame(animate); return; }
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const w = window.innerWidth, h = window.innerHeight;
      if (canvas.width !== w*dpr || canvas.height !== h*dpr) {
        canvas.width = w*dpr; canvas.height = h*dpr; ctx.scale(dpr,dpr);
      }
      ctx.clearRect(0,0,w,h);
      globalTime += 0.016;

      const wf = binaural.started ? binaural.getWaveformData() : null;
      const cat = categories[currentCatKey.value];
      if (cat) cat.draw(ctx, w, h, globalTime, mouseX.value, mouseY.value, wf);

      // Audio waveform ring
      if (wf) {
        const cx = w/2, cy = h/2, bR = Math.min(w,h)*0.18;
        ctx.beginPath();
        for (let i = 0; i < wf.length; i++) {
          const a = (i/wf.length)*Math.PI*2;
          const r = bR + (wf[i]-128)/128*25;
          const x = cx+r*Math.cos(a), y = cy+r*Math.sin(a);
          i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.strokeStyle = accentColor.value.replace(/[\d.]+\)$/, '0.15)');
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Vignette
      const vG = ctx.createRadialGradient(w/2,h/2,w*0.2,w/2,h/2,w*0.7);
      vG.addColorStop(0,'rgba(8,6,13,0)');
      vG.addColorStop(1,'rgba(8,6,13,0.7)');
      ctx.fillStyle = vG;
      ctx.fillRect(0,0,w,h);

      animFrame = requestAnimationFrame(animate);
    }

    onMounted(() => {
      animate();
      window.addEventListener('click', handleClick);
      window.addEventListener('mousemove', handleMouseMove);
    });

    onUnmounted(() => {
      cancelAnimationFrame(animFrame);
      clearInterval(timelapseTimer);
      binaural.destroy();
      window.removeEventListener('click', handleClick);
      window.removeEventListener('mousemove', handleMouseMove);
    });

    const barColor = computed(() => categories[currentCatKey.value]?.colorBright || '#7b5ea7');

    return {
      canvasRef, currentWord, currentFormula, currentCategory, currentBeatInfo,
      isFading, timelapseProgress, accentColor, barColor,
      mouseX, mouseY, audioInitialized, volume, handleVolumeChange
    };
  },
  template: `
    <div style="width:100%;height:100%;position:relative;">
      <canvas ref="canvasRef"></canvas>
      <div class="audio-init-overlay" :class="{ hidden: audioInitialized }">
        <h1>trance tone engine</h1>
        <p>click to begin</p>
        <p class="headphones-warn">\u26A0 stereo headphones required for binaural effect</p>
      </div>
      <div class="overlay">
        <div class="category-label" :class="{ fading: isFading }" :style="{ color: accentColor }">{{ currentCategory }}</div>
        <div class="word-display" :class="{ fading: isFading }">{{ currentWord }}</div>
        <div class="formula-display" :class="{ fading: isFading }">{{ currentFormula }}</div>
        <div class="beat-info" :class="{ fading: isFading }">{{ currentBeatInfo }}</div>
      </div>
      <div class="volume-control" v-if="audioInitialized">
        <label>vol</label>
        <input type="range" min="0" max="100" :value="volume" @input="handleVolumeChange" />
      </div>
      <div class="click-hint" v-if="audioInitialized">click anywhere to shift \u00B7 auto-advances</div>
      <div class="timelapse-bar" :style="{ width: (timelapseProgress*100)+'%', background: barColor }"></div>
      <div class="cursor-glow" :style="{ left: mouseX+'px', top: mouseY+'px', background: 'radial-gradient(circle,'+accentColor+',transparent)', width:'40px', height:'40px' }"></div>
    </div>
  `
};

createApp({ components: { 'trance-engine': TranceEngine } }).mount('#app');
</script>
</body>
</html>
